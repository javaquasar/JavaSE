package com.javaquasar.java.core.chapter_17_Thread.phaser;

import java.util.concurrent.*;

/**
 * Created by Java Quasar on 16.05.17.
 */
/*Phaser (фазер)

 Самым интересным инструментом является фазер. Он похож на циклический барьер, но выполняет другую ф-цию. 
 Предположим у нас есть несколько потоков, которые запущенны параллельно из главного. Каждый из потоков 
 с начало создает переменную, затем присваивает значение, после чего выводит ее значение на терминал. 
 Условно разделим роботу потока на 3 фазы: создание, присвоение, вывод. Мы хотим, чтобы потоки работали 
 синхронно по фазам. То бишь, потоки не продолжают работу до тех пор, пока каждый из потоков не завершит 
 фазу.

 Прежде чем приступим к рассмотрению примера рассмотрим сам класс.

 Он имеет большое количество методов, а также перегруженные конструкторы.

 Конструкторы:

 Phaser() Phaser(int party)
 Первый конструктор указывает нулевое количество сторон, а второму конструктору передается параметр 
 целочисленного типа указывающий на количество зарегистрированных сторон. Сторона — это объект который 
 зарегистрированный для работы с фазами. Зачем нужно два конструктора, будет рассмотрено в примере, а 
 пока взгляним на методы позволяющие делать фазы.

 int register() 
 Данный метод вызывается из потока который хочет зарегистрироваться. В результате возвращается номер 
 зарегистрированной фазы.

 int arrive() 
 Этот метод указывает что он завершил выполнение фазы, и возвращает номер фазы, если же работа фазера 
 закончена, он возвращает отрицательное число. При вызове данного метода поток не приостанавливает, 
 а продолжает выполнятся.

 int arriveAndAwaitAdvance() 
 Этот метод указывает что он завершил выполнение фазы и приостанавливает текущий поток до момента, 
 пока все потоки не закончат выполнять данную фазу. Также он возвращает номер фазы.
 int arriveAndDeregister() 
 Принцип работы данного метода аналогичен предыдущему, но так же, он отменяет регистрацию. 
 final int getPhase() возвращает номер текущей фазы.

 Чтобы детально понять работу фазера, рассмотрим пример:
 Изначально фазеру указывается количество сторон — равен одному. Это нужно затем, что главный поток 
 не регистрируется. Дальше создаются три потока MyThread которым передается строка и фазер. 
 В конструкторе каждого потока регистрируется сторона. Затем запускается выполнения каждого потока. 
 За счет методов arriveAndAwaitAdvancе каждый поток не продолжает свою работу до тех пор пока все не 
 закончат текущею фазу. В конце вызывается метод arriveAndDeregister который отменяет регистрацию сторон. 
 В главном потоке (main) так же вызываются эти методы, который дожидается окончание работы фаз, 
 после чего выводит номер завершения фазы. В конце главный поток отменяет свою регистрацию и программа 
 завершается.*/

class MyThread implements Runnable {
	private String str;
	private Phaser p;

	MyThread(String str, Phaser p) {
		this.str = str;
		this.p = p;
		this.p.register();
		new Thread(this).start();
	}

	@Override
	public void run() {
		String tmp;
		System.out.println("Создание переменной");
		p.arriveAndAwaitAdvance();
		tmp = str;
		System.out.println("Присваивание переменной значение");
		p.arriveAndAwaitAdvance();
		System.out.println("tmp = " + tmp);
		p.arriveAndDeregister();
	}
}

public class Test {
	public static void main(String[] args) {
		Phaser p = new Phaser(3);
		new MyThread("A", p);
		new MyThread("B", p);
		new MyThread("C", p);
		int num = p.getPhase();
		p.arriveAndAwaitAdvance();
		System.out.println("Конец фазы#" + num);
		num = p.getPhase();
		p.arriveAndAwaitAdvance();
		System.out.println("Конец фазы#" + num);
		num = p.getPhase();
		p.arriveAndAwaitAdvance();
		System.out.println("Конец фазы#" + num);
		p.arriveAndDeregister();
	}
}
/*
 * Создание переменной 
 * Создание переменной 
 * Создание переменной 
 * Конец фазы#0
 * Присваивание переменной значение 
 * Присваивание переменной значение
 * Присваивание переменной значение 
 * Конец фазы#1 
 * tmp = B 
 * tmp = A 
 * tmp = C 
 * Конец фазы#2
 */